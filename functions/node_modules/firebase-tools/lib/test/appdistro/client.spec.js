"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon = require("sinon");
const client_1 = require("../../appdistribution/client");
const error_1 = require("../../error");
const api = require("../../api");
const nock = require("nock");
describe("distribution", () => {
    const appId = "1:12345789:ios:abc123def456";
    const distribution = new client_1.AppDistributionClient(appId);
    let sandbox;
    beforeEach(() => {
        sandbox = sinon.createSandbox();
        sandbox.useFakeTimers();
    });
    afterEach(() => {
        sandbox.restore();
    });
    describe("getApp", () => {
        it("should throw error when app does not exist", () => {
            nock(api.appDistributionOrigin)
                .get(`/v1alpha/apps/${appId}`)
                .reply(404, {});
            return chai_1.expect(distribution.getApp()).to.be.rejected;
        });
        it("should resolve when request succeeds", () => {
            nock(api.appDistributionOrigin)
                .get(`/v1alpha/apps/${appId}`)
                .reply(200, {});
            return chai_1.expect(distribution.getApp()).to.be.fulfilled;
        });
        it("should throw an error when the request fails", () => {
            nock(api.appDistributionOrigin)
                .get(`/v1alpha/apps/${appId}`)
                .reply(404, {});
            return chai_1.expect(distribution.getApp()).to.be.rejected;
        });
    });
    describe("getJwtToken", () => {
        it("should throw error if request fails", () => {
            nock(api.appDistributionOrigin)
                .get(`/v1alpha/apps/${appId}/jwt`)
                .reply(400, {});
            return chai_1.expect(distribution.getJwtToken()).to.be.rejected;
        });
        describe("when request succeeds", () => {
            it("should return null when response does not contain the token", () => {
                nock(api.appDistributionOrigin)
                    .get(`/v1alpha/apps/${appId}/jwt`)
                    .reply(200, {});
                return chai_1.expect(distribution.getJwtToken()).to.be.eventually.eq(undefined);
            });
            it("should return the token", () => {
                const fakeToken = "fake-token";
                nock(api.appDistributionOrigin)
                    .get(`/v1alpha/apps/${appId}/jwt`)
                    .reply(200, { token: fakeToken });
                return chai_1.expect(distribution.getJwtToken()).to.be.eventually.eq(fakeToken);
            });
        });
    });
    describe("pollReleaseIdByHash", () => {
        describe("when request fails", () => {
            it("should throw error when retry count >= AppDistributionClient.MAX_POLLING_RETRIES", () => {
                sandbox.stub(distribution, "getReleaseIdByHash").rejects(new Error("Can't find release"));
                return chai_1.expect(distribution.pollReleaseIdByHash("mock-hash", client_1.AppDistributionClient.MAX_POLLING_RETRIES)).to.be.rejectedWith(error_1.FirebaseError, "Can't find release");
            });
        });
        it("should return release id when request succeeds", () => {
            const releaseId = "fake-release-id";
            sandbox.stub(distribution, "getReleaseIdByHash").resolves(releaseId);
            return chai_1.expect(distribution.pollReleaseIdByHash("mock-hash", client_1.AppDistributionClient.MAX_POLLING_RETRIES)).to.eventually.eq(releaseId);
        });
    });
    describe("getReleaseIdByHash", () => {
        it("should throw an error when request fails", () => {
            const fakeHash = "fake-hash";
            nock(api.appDistributionOrigin)
                .get(`/v1alpha/apps/${appId}/release_by_hash/${fakeHash}`)
                .reply(400, {});
            return chai_1.expect(distribution.getReleaseIdByHash(fakeHash)).to.be.rejectedWith(error_1.FirebaseError, "HTTP Error: 400");
        });
        describe("when request succeeds", () => {
            it("should return undefined when it cannot parse the response", () => {
                const fakeHash = "fake-hash";
                nock(api.appDistributionOrigin)
                    .get(`/v1alpha/apps/${appId}/release_by_hash/${fakeHash}`)
                    .reply(200, {});
                return chai_1.expect(distribution.getReleaseIdByHash(fakeHash)).to.eventually.eq(undefined);
            });
            it("should return the release id", () => {
                const releaseId = "fake-release-id";
                const fakeHash = "fake-hash";
                nock(api.appDistributionOrigin)
                    .get(`/v1alpha/apps/${appId}/release_by_hash/${fakeHash}`)
                    .reply(200, { release: { id: releaseId } });
                return chai_1.expect(distribution.getReleaseIdByHash(fakeHash)).to.eventually.eq(releaseId);
            });
        });
    });
    describe("addReleaseNotes", () => {
        it("should return immediately when no release notes are specified", () => __awaiter(this, void 0, void 0, function* () {
            const apiSpy = sandbox.spy(api, "request");
            yield chai_1.expect(distribution.addReleaseNotes("fake-release-id", "")).to.eventually.be.fulfilled;
            chai_1.expect(apiSpy).to.not.be.called;
        }));
        it("should throw error when request fails", () => {
            const releaseId = "fake-release-id";
            nock(api.appDistributionOrigin)
                .post(`/v1alpha/apps/${appId}/releases/${releaseId}/notes`)
                .reply(400, {});
            return chai_1.expect(distribution.addReleaseNotes(releaseId, "release notes")).to.be.rejectedWith(error_1.FirebaseError, "failed to add release notes");
        });
        it("should resolve when request succeeds", () => {
            const releaseId = "fake-release-id";
            nock(api.appDistributionOrigin)
                .post(`/v1alpha/apps/${appId}/releases/${releaseId}/notes`)
                .reply(200, {});
            return chai_1.expect(distribution.addReleaseNotes(releaseId, "release notes")).to.eventually.be
                .fulfilled;
        });
    });
    describe("enableAccess", () => {
        it("should return immediately when testers and groups are empty", () => __awaiter(this, void 0, void 0, function* () {
            const apiSpy = sandbox.spy(api, "request");
            yield chai_1.expect(distribution.enableAccess("fake-release-id")).to.eventually.be.fulfilled;
            chai_1.expect(apiSpy).to.not.be.called;
        }));
        it("should resolve when request succeeds", () => {
            const releaseId = "fake-release-id";
            nock(api.appDistributionOrigin)
                .post(`/v1alpha/apps/${appId}/releases/${releaseId}/enable_access`)
                .reply(200, {});
            return chai_1.expect(distribution.enableAccess(releaseId, ["tester1"], ["group1"])).to.be.fulfilled;
        });
        describe("when request fails", () => {
            let testers;
            let groups;
            beforeEach(() => {
                testers = ["tester1"];
                groups = ["group1"];
            });
            it("should throw invalid testers error when status code is FAILED_PRECONDITION ", () => {
                const releaseId = "fake-release-id";
                nock(api.appDistributionOrigin)
                    .post(`/v1alpha/apps/${appId}/releases/${releaseId}/enable_access`, {
                    emails: testers,
                    groupIds: groups,
                })
                    .reply(412, { error: { status: "FAILED_PRECONDITION" } });
                return chai_1.expect(distribution.enableAccess(releaseId, testers, groups)).to.be.rejectedWith(error_1.FirebaseError, "failed to add testers/groups: invalid testers");
            });
            it("should throw invalid groups error when status code is INVALID_ARGUMENT", () => {
                const releaseId = "fake-release-id";
                nock(api.appDistributionOrigin)
                    .post(`/v1alpha/apps/${appId}/releases/${releaseId}/enable_access`, {
                    emails: testers,
                    groupIds: groups,
                })
                    .reply(412, { error: { status: "INVALID_ARGUMENT" } });
                return chai_1.expect(distribution.enableAccess(releaseId, testers, groups)).to.be.rejectedWith(error_1.FirebaseError, "failed to add testers/groups: invalid groups");
            });
            it("should throw default error", () => {
                const releaseId = "fake-release-id";
                nock(api.appDistributionOrigin)
                    .post(`/v1alpha/apps/${appId}/releases/${releaseId}/enable_access`, {
                    emails: testers,
                    groupIds: groups,
                })
                    .reply(400, {});
                return chai_1.expect(distribution.enableAccess(releaseId, ["tester1"], ["group1"])).to.be.rejectedWith(error_1.FirebaseError, "failed to add testers/groups");
            });
        });
    });
});
//# sourceMappingURL=client.spec.js.map